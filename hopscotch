#!/usr/bin/env perl

use 5.010;
use warnings;
use strict;

use Crypt::Mac::HMAC qw(hmac_hex);
use URI::Split qw(uri_split);
use Furl::HTTP;
use List::MoreUtils qw(natatime);
use Try::Tiny;

use constant KEY           => $ENV{HOPSCOTCH_KEY}           // die "HOPSCOTCH_KEY not set\n";
use constant HOST          => $ENV{HOPSCOTCH_HOST}          // "unknown";
use constant TIMEOUT       => $ENV{HOPSCOTCH_TIMEOUT}       // 60;
use constant HEADER_VIA    => $ENV{HOPSCOTCH_HEADER_VIA}    // "hopscotch";
use constant HEADER_UA     => $ENV{HOPSCOTCH_HEADER_UA}     // "hopscotch";
use constant LENGTH_LIMIT  => $ENV{HOPSCOTCH_LENGTH_LIMIT}  // 5242880;
use constant MAX_REDIRECTS => $ENV{HOPSCOTCH_MAX_REDIRECTS} // 4;
use constant PARANOID      => $ENV{HOPSCOTCH_PARANOID}      // 0;
use constant ERRORS        => $ENV{HOPSCOTCH_ERRORS}        // 1;
use constant CAFILE        => $ENV{HOPSCOTCH_CAFILE}        // undef;
use constant CAPATH        => $ENV{HOPSCOTCH_CAPATH}        // undef;

require Net::DNS::Paranoid if PARANOID;

my %COPY_REQUEST_HEADERS = map { $_ => 1 } qw(
    accept accept-language cache-control if-modified-since if-match if-none-match if-unmodified-since
);

my %COPY_RESPONSE_HEADERS = map { $_ => 1 } qw(
    content-type cache-control etag expires last-modified content-length content-type server
);

my %VALID_CONTENT_TYPES = map { $_ => 1 } qw(
    image/bmp
    image/bitmap
    image/cgm
    image/g3fax
    image/gif
    image/ief
    image/jp2
    image/jpg
    image/jpeg
    image/pict
    image/png
    image/prs.btif
    image/svg+xml
    image/tiff
    image/vnd.adobe.photoshop
    image/vnd.djvu
    image/vnd.dwg
    image/vnd.dxf
    image/vnd.fastbidsheet
    image/vnd.fpx
    image/vnd.fst
    image/vnd.fujixerox.edmics-mmr
    image/vnd.fujixerox.edmics-rlc
    image/vnd.microsoft.icon
    image/vnd.ms-modi
    image/vnd.net-fpx
    image/vnd.wap.wbmp
    image/vnd.xiff
    image/x-cmu-raster
    image/x-cmx
    image/x-macpaint
    image/x-pcx
    image/x-pict
    image/x-portable-anymap
    image/x-portable-bitmap
    image/x-portable-graymap
    image/x-portable-pixmap
    image/x-quicktime
    image/x-rgb
    image/x-xbitmap
    image/x-xpixmap
    image/x-xwindowdump
);

sub request_headers {
    my ($headers) = @_;
    my $it = natatime 2, @$headers;
    [
        (map { my ($k, $v) = $it->(); exists $COPY_REQUEST_HEADERS{lc($k)} ? ($k, $v) : () } (1..(scalar @$headers)/2)),
        'Via' => HEADER_VIA,
    ];
}

sub response_headers {
    my ($headers) = @_;
    my $it = natatime 2, @$headers;
    [
        (map { my ($k, $v) = $it->(); exists $COPY_RESPONSE_HEADERS{lc($k)} ? ($k, $v) : () } (1..(scalar @$headers)/2)),
        'Via' => HEADER_VIA,
        'Hopscotch-Host' => HOST,
    ];
}

sub cleanup_error {
    return unless ERRORS;
    my ($err) = @_;
    $err =~ s/ at .+ line.*//sm;
    "E: $err\n";
}

sub response {
    my $err;
    if (defined $_[2]) {
        $err = cleanup_error($_[2]) if defined $_[2];
        warn $err;
    }
    [ $_[0], response_headers($_[1] // []), [ $err // () ] ];
}

my %header_checks = (
    "content-length" => sub { 0+$_[0] <= LENGTH_LIMIT },
    "content-type"   => sub { exists $VALID_CONTENT_TYPES{lc(($_[0] =~ m/^([^;]+)/)[0] // "")} },
);

sub rejected {
    my ($code, $msg, $headers) = @_;

    {
        my $codetype = substr $code, 0, 1;
        return (1, "remote returned $code $msg") if $codetype < 2 || $codetype > 3;
    };

    {
        my $it = natatime 2, @$headers;
        while (my ($k, $v) = $it->()) {
            return (1, "remote failed header check '$k' with value '$v'") if exists $header_checks{$k} && !$header_checks{$k}->($v);
        }
    }

    return (0);
}

my $furl = Furl::HTTP->new(
    timeout       => TIMEOUT,
    max_redirects => MAX_REDIRECTS,
    agent         => HEADER_UA,
    ssl_opts      => {
        CAFILE ? (SSL_ca_file => CAFILE) : (),
        CAPATH ? (SSL_ca_path => CAPATH) : (),
    },
);

my $dns = PARANOID ? Net::DNS::Paranoid->new : undef;

sub app {
    my ($env) = @_;

    return response(405, [], "request method must be GET or HEAD (not $env->{REQUEST_METHOD})") unless $env->{REQUEST_METHOD} =~ m/^GET|HEAD$/;

    my (undef, $mac, $hexurl) = split '/', $env->{REQUEST_URI};

    return response(404, [], "invalid URL structure (MAC/hex)") unless defined $mac && defined $hexurl;
    return response(404, [], "invalid characters in hex fragment") unless $hexurl =~ m/^[0-9a-f]+$/;

    my $url = pack "h*", $hexurl;
    my $our_mac = hmac_hex('SHA256', KEY, $url);

    return response(404, [], "invalid MAC") unless lc($mac) eq lc($our_mac);

    if (PARANOID) {
        my ($host) = [uri_split($url)]->[1] =~ m/\@?([^\@]+)$/;
        my ($addrs) = try { $dns->resolve($host) };
        return response(404, [], "attempt to access '$host' in paranoid mode") unless defined $addrs;
    }

    return sub {
        my ($respond) = @_;

        my $w;
        my $bytes = 0;

        my (undef, $code, $msg, $headers, $body) = try {
            $furl->request(
                method     => $env->{REQUEST_METHOD},
                url        => $url,
                headers    => request_headers([map { (substr($_, 5) =~ s/_/-/gr) => $env->{$_} } grep { m/^HTTP_/ } keys %$env]),
                write_code => sub {
                    my ($code, $msg, $headers, @rest) = @_;

                    my ($rejected, $err) = rejected($code, $msg, $headers);
                    die $err if $rejected;

                    unless (defined $w) {
                        $w = $respond->([@{response($code, $headers)}[0,1]]);
                    }

                    if (defined $rest[0]) {
                        $bytes += length $rest[0];
                        die "remote file exceeded length limit\n" if $bytes > LENGTH_LIMIT;
                        $w->write($rest[0]);
                    }
                    else {
                        $w->close;
                    }
                }
            );
        }
        catch {
            if ($w) {
                # part way through stream so we can't return the error to the client
                warn cleanup_error("stream aborted: $_");
                $w->close;
            }
            else {
                $respond->(response(404, [], $_));
            }
            $w = 1; # flag that we've responded
        };

        unless ($w) {
            my ($rejected, $err) = rejected($code, $msg, $headers);
            if ($rejected) {
                return $respond->(response(404, [], $err));
            }
            return $respond->(response($code, $headers));
        }
    };
}

if (my ($url) = @ARGV) {
    $url =~ s{http://[^/]+}{};
    my $r = app({
        REQUEST_METHOD => 'GET',
        REQUEST_URI    => $url,
    });

    if (ref $r eq "ARRAY") {
        # error already output in response()
        exit 0;
    }

    if (ref $r eq "CODE") {
        open my $w, '<', '/dev/null';
        my $respond = sub { $w };
        $r->($respond);
    }

    exit 0;
}

if (caller) {
    return \&app;
}
